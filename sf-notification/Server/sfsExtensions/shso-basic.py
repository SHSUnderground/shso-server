# shso basic
#
# import mysql.connector
import time
import datetime

def init():
	global db 
	global cmdMap
	global srvVer
	global validCliVer

	srvVer = "00.00.017"
	validCliVer = "00.00.017"
	cmdMap = {"ping": handlePing, "keepAlive": handleKeepAlive }
	
	db = _server.getDatabaseManager()


def destroy():
	_server.trace( "Python extension dying" )


def escapeQuotes(string):
	string2 = str(string).replace( '"', '\"')
	string2 = string2.replace( "'", "\'")
	string2 = string2.replace("\\", "\\\\")
	return string2


def handleRequest(cmd, params, who, roomId, protocol):
	#if protocol == "xml":
	if cmdMap.has_key(cmd):
		cmdMap[cmd](params, who, roomId)
		

def handleInternalEvent(evt):
	chan = evt.getObject("chan")
	# nick = "chumbawumbA"
	nick = evt.getParam("nick")
	passw = evt.getParam("pass")
	cliVer = None
	debugFlags = None
	md5hash = None
	# Get the secret key of this channel
	key = _server.getSecretKey(chan)
	_server.trace("key = " + str(key))

	#_server.trace("evt = " + ' '.join(map(str, dir(evt))) )
	evtName = evt.getEventName()
	_server.trace( "Received internal event: " + evt.getEventName() )
	if evtName == "loginRequest":
		#### special case if user nick starts with 'version=', we do a client/server version validation.  #######
		importantInfo = nick.split(',')	
		if len(importantInfo) > 1:
			nick = importantInfo[0]
			cliVer = importantInfo[1]
			_server.trace("attempting client/server version validation!")
			_server.trace("cliVer=" + cliVer)
			_server.trace("nick=" + escapeQuotes(nick))
			
			#if client version isnt what is expected, do the following:
			valid = False
			if (cliVer == validCliVer):
				valid = True
			if valid == False:
				user = _server.getUserByChannel(chan)

				response = {}
				response["_cmd"] = "logKO"
				response["err"] = "Invalid client version"
				response["status"] = 403
				_server.sendResponse(response, -1, None, chan)
				#_server.disconnectUser(user)  # disconnect client if version does not validate.
				return
		else:
			response = {}
			response["_cmd"] = "logKO"
			response["err"] = "Wrong client , use launcher to check for updates"
			response["status"] = 403
			_server.sendResponse(response, -1, None, chan)
			return

		#########################################################################################	
	
		error = ""
		valid = 0
		response = {}
		user = None
		session_token = None
		userIP = chan.socket().getInetAddress().getHostAddress()
		queryRes = None
		checkSQL = "SELECT * FROM user WHERE username = '" + escapeQuotes(nick) + "' AND MD5(CONCAT(" + key + ", Password)) = '" + escapeQuotes(passw) + "';"
		UserCheckQueryResult = db.executeQuery(checkSQL)
		if (UserCheckQueryResult) and (UserCheckQueryResult.size() > 0):
				queryRes = UserCheckQueryResult
				row = queryRes.get(0)
				username = row.getItem("Username")
				playerID = row.getItem("ID")
				paid = row.getItem("Paid")
				dbpass = row.getItem("Password")
				# session_token = generate_token()
				gentoken = "SELECT UUID() AS token;"
				tokenQuery = db.executeQuery(gentoken)
				if (tokenQuery.size() > 0):
					for row in tokenQuery:
						session_token = str(row.getItem("token"))
				# _server.trace('TOKEN GENERATED SUCCESSFULLY.')
				sql = "INSERT INTO tokens VALUES(" + escapeQuotes(str(playerID)) + ", '" + escapeQuotes(session_token) + "') ON DUPLICATE KEY UPDATE token='" + escapeQuotes(session_token) + "'"
				success = db.executeCommand(sql)
				if not success:
					error = "Record insertion failed."
				else:
					response["_cmd"] = "logOK"
					obj = _server.loginUser(nick, dbpass, chan)
							#if obj.success == true:
					_server.trace("Calling getUserByChannel()!")
					user = _server.getUserByChannel(chan)
					response["name"] = username
					# the ID returned HAS to be the userId generated by smartfox.
					response["id"] = str(user.getUserId())
					#response["id"] = ID 
					response["playerId"] = playerID
					response["paid"] = paid
					response["sessionToken"] = str(session_token)
					
					# now write login date
					ts = time.time()
					timestamp = datetime.datetime.fromtimestamp(ts).strftime('%Y-%m-%d %H:%M:%S')
					ip = user.getIpAddress()

					sql = "UPDATE shso.user SET LastLogin = '" + escapeQuotes(timestamp) + "'  WHERE username = '" + escapeQuotes(nick) + "'";
					success = db.executeCommand(sql)

		# elif valid == -1:
		# 	response["_cmd"] = "logKO"
		# 	response["err"] = failMsg
		# 	response["status"] = 443
		# 	_server.trace(failMsg)

		_server.trace("Calling sendResponse()!")
		_server.sendResponse(response, -1, None, chan)

		response = {}
		if error == "":
			_server.trace("Calling sendRoomList()!")
			_server.sendRoomList(user)
			_server.trace("Called sendRoomList()!")
			zone = _server.getCurrentZone()
			room = zone.getRoomByName("lobby")	
			_server.joinRoom(user,-1,True,room.getId(),"",False,True)
			response["_cmd"] = "notification_ready"
		else: 
			response["_cmd"] = "logKO"
		_server.sendResponse(response, -1, None, [user])




def handlePing(params, who, roomId):
	response = {}
	response["_cmd"] = "ping"

	_server.sendResponse(response, -1, None, [who])
	
def handleKeepAlive(params, who, roomId):
	response = {}
	response["_cmd"] = "keepAlive"

	_server.sendResponse(response, -1, None, [who])
